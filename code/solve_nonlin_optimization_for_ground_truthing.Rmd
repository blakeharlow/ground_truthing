---
title: "solve_nonlin_optimization_for_ground_truthing"
author: "Blake Harlow"
date: "6/29/2021"
last edited: "6/29/2021"
output: pdf_document
---

```{r setup, include = FALSE}
gc()
rm(list=ls())
require("knitr")
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())

getwd()
```

```{r, import_libraries, warning = "hide", message = FALSE}
library(dplyr)
library(tidyr)
library(ggplot2)
library(readxl)
library(rgl)
library(seewave)  # has rms() function

source("code/makeCleanData.R")
```

Open the excel file as a tibble using readxl::read_excel()

```{r, read_data}
excel_path <- "raw_data/2021_06_23_ground_truthing.xlsx"
data <- read_excel(excel_path) %>%
  mutate(rn = row_number()) # This will enable me to track each sighting
clean_data <- data %>% makeCleanData()
  
# This is a vector showing the order of the <x> vector.
levels <- c("a20","a46","a53","a57","a61","a75","a76","a78","a87","a98",
            "t1","t2","t3","t4","t5","t6","t7",#"t8","t9","t10","t11","t12",
            "t13","t14","t15","t16",
            "p1","p2")


# make an initial guess from lin lst sqrs. Order this by levels vector
initial_results <- read.table("./clean_data/initial_results.csv")
initial_guess <- initial_results[match(levels, initial_results$position),]
# Now alternate x,y, and z to get i_guess vector of form <x1,x2,x3,...,xn,yn,zn.
i_guess <- c(rbind(initial_guess$x, initial_guess$y,initial_guess$z))

# make the first point the origin
i_guess_o_shift <- i_guess[1:3]
i_guess_trunc <- i_guess - i_guess_o_shift
i_guess_trunc <- i_guess_trunc[-(1:3)]

# scale h and v:
len_scale <- 10
i_guess_trunc <- i_guess_trunc * len_scale
clean_data_scaled <- clean_data %>%
  mutate(horizontal_side = horizontal_side * len_scale,
         vertical_side = vertical_side * len_scale)
```


```{r}
# This function takes a vector of position data: <x1,y1,z1,...,xn,yn,zn> and 
# returns the hypothetical vertical leg length, horizontal leg length, and 
# bearing measurements for each bearing given those positions.

getMeasurements <- function(x, clean_data) {
  # initialize an empty output y vector
  y <- vector(mode = "numeric", length = 0L)
  x <- c(0,0,0,x)
  
  # loop through each bearing in clean_data
  for (sighting in 1:dim(clean_data)[1]){
    # get the string positions for the laser and target
    laser_position <- clean_data$laser_position[sighting]
    target_position <- clean_data$target_position[sighting]
    
    # using the levels vector, find the indeces for laser and target positions
    laser_position_index <- which(levels == laser_position)
    target_position_index <- which(levels == target_position)
    
    # retrieve positions for laser and target using the indeces found above
    laser_x <- x[laser_position_index * 3 - 2]
    laser_y <- x[laser_position_index * 3 - 1]
    laser_z <- x[laser_position_index * 3]
    
    target_x <- x[target_position_index * 3 - 2]
    target_y <- x[target_position_index * 3 - 1]
    target_z <- x[target_position_index * 3]
    
    # compute the hypothetical measurements and append to y
    v <- target_z - laser_z - clean_data$laser_height[sighting] + clean_data$target_height[sighting]
    h <- ((target_x - laser_x)^2 + (target_y - laser_y)^2)^(1/2)
    theta <- atan2((target_x - laser_x),(target_y - laser_y))
    y <- y %>% append(v)
    y <- y %>% append(h)
    y <- y %>% append(theta)
  }
  
  return(y)
}

```


```{r}
# Now construct the measured y vector:

y_measured <- vector(mode = "numeric", length = 0L)

# loop through each bearing in clean_data
for (sighting in 1:dim(clean_data)[1]){
  y_measured <- y_measured %>% append(clean_data$vertical_side[sighting])
  y_measured <- y_measured %>% append(clean_data$horizontal_side[sighting])
  y_measured <- y_measured %>% append(clean_data$bearing[sighting])
}

```


```{r}
# Now construct the actual function to minimize.

function_to_minimize <- function(x, clean_data){
  return(sum((getMeasurements(x, clean_data) - y_measured)^2))
}

function_to_minimize(i_guess_trunc, clean_data_scaled)

```


```{r}
# Now complete the optimization:

optim(i_guess_trunc, function_to_minimize, clean_data = clean_data_scaled,
      method = "BFGS", control = list(trace = TRUE))
```

```{r}
# convert back to 


```